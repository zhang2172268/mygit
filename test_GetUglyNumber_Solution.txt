/*丑数
     
   题目描述：
           把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
*/

/*解析：
   把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

要理解下面的算法需要注意： 
1.每个丑数都是之前的丑数 *2 ， *3 ， *5 的结果

2.一个丑数 * x (x=2,3,5) 的结果都要加入到答案序列中，但是每次只能加入最小的那个。一旦一个丑数 * x (x=2,3,5) 被加入到答案序列中，那么当前丑数就要更新为答案序列中下一个丑数。 
例如：当前答案序列 1 
我们会得到 3 个待选丑数 2 3 5 
我们选择最小的2加入到答案序列中，更新答案序列为：1 2 
此时 3 个待选丑数变为 4 3 5 (4=2*2) 
我们选择最小的3加入到答案序列中，更新答案序列为：1 2 3 
此时 3 个待选丑数变为 4 6 5 (6=2*3) 
我们选择最小的4加入到答案序列中，更新答案序列为：1 2 3 4 
此时 3 个待选丑数变为 6 6 5 (6=3*2) 
我们选择最小的5加入到答案序列中，更新答案序列为：1 2 3 4 5 
此时 3 个待选丑数变为 6 6 10 (10=2*5) 
…. 
这样得到的答案序列一定为升序
*/

class Solution {
public:
    int GetUglyNumber_Solution(int index) {
        if(index==1)
            return 1;
        int x2,x3,x5;
        x2=x3=x5=0;
        int *ug=new int[index];
        ug[0]=1;
        for(int i=1;i<index;i++){
            int t = min(ug[x2]*2,min(ug[x3]*3,ug[x5]*5));
            if(t==ug[x2]*2) x2++;
            if(t==ug[x3]*3) x3++;
            if(t==ug[x5]*5) x5++;
            ug[i]=t;
        }
        return ug[index-1];
    }
};